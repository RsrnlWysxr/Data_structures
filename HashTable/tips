 哈希表：
每个数据类型都和一个索引相对应
“键" 转换为 "索引" --> 哈希函数
数组实现  -->  支持随机访问 --> 查找操作 O(1)
哈希冲突 --> 键和索引并非一一对应
经典思想：空间换时间		哈希寻求时空平衡

哈希函数设计：
均匀性：“键”通过哈希函数得到的“索引”分布越均匀越好
一致性：a == b  --> hash (a) == hash(b)
高效性：计算高效简单
整型：
小范围正整数 --> 直接使用
小范围负整数 --> 偏移
大整数 （如身份证） --> 取模 --> mod 1000 --> 取后四位
分布不均匀 --> 更好的 模一个素数 
浮点型 --> 根据底层浮点型在计算机中的表示 --> 转换为整型
字符串 --> 想成26进制的表示 --> 转换为整型
变形：hash(code) = ((((c * B) + o ) * B + d) * B + e) %M
防止整型溢出：
hash(code) =  ((((c % M) * B + o ) % M * B + d) % M * B + e) % M
int hash = 0;
for (int i = 0 ; i < s.length() ;  ++i)
hash = (hash * B + s.charAt(i)) % M;
复合类型 --> 同字符串 --> 转换为整型

哈希冲突的处理 --> 链地址方法
开M个空间，每个空间 存 TreeMap，有冲突在树中插入即可
复杂度：
M个空间，N个元素，均匀，每个空间N / M 个元素
每个空间是链表：O（N / M）
每个空间是平衡树：O（log N / M）
动态空间处理：
平均每个空间承载的元素多过一定程度，即扩容
N / M >= upperTol
平均每个空间承载的元素少过一定程度，即缩容
N / M < lowerTol
保证新的M为素数 --> 使用已确定的素数表 --> 即创建一个素数表
劣势：
缺失了顺序性
以上解决哈希冲突 是 封闭空间的方法 --> 每个地址只对相应key开放

开放地址法：（对每个key开放）
线性探测  --> 每个地址就存元素，发生哈希冲突，放在本该放的位置后面的非空位置
平方探测  --> 每次冲突 + 1   +4    +9   +16
二次哈希 --> 使用另外一个哈希函数  +hash2(key)
