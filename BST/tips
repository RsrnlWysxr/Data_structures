二分搜索树
--> 二叉树：
和链表一样，动态数据结构 --> 初始不用规定大小
class Node{
E e;
Node left;		<-- 左孩子
Node right;	<-- 右孩子
}
唯一根节点 --> 最上面的节点，每个节点最多有两个孩子，叶子节点 --> 没有左右孩子
每个节点最多有一个父节点，根节点没有父节点
具有天然递归结构
每个节点的左子树也是二叉树
每个节点的右子树也是二叉树
二分搜索树  --> 每个节点的值
大于其左子树的所有节点的值
小于其右子树的所有节点的值
每一颗子树也是二分搜索树
存储的元素必须有可比较性
深度优先遍历：(使用栈)
前序遍历 --> 	访问该节点 --> 访问左子树 --> 访问右子树
中序遍历 -->	访问左子树 --> 访问该节点 --> 访问右子树  --> 结果为升序排列
后序遍历 -->	访问左子树 --> 访问右子树 --> 访问该节点   --> 应用：为二分搜索树释放内存
其实每个节点都访问了三次，都是先看根节点，再左子树，再跟节点，再右子树，再根节点，前中后遍历就是在哪一次进行操作
广度优先遍历：(使用队列)
层序遍历 -->	逐层遍历
删除元素思路：
删除左右都有孩子的节点d
找到s = min (d->right)
s是d的后继 --> 即用s取代替d
或 s = max (d -> left)
s是d的前驱 --> 即用s取代替d
复杂度：	o(h)   h-->深度
==> o(log n)
局限性 --> 按顺序加入数据，二分搜索树退化成链表
解决 --> 平衡二叉树
