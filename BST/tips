	#include <iostream>
	#include <stack>
	
	template <typename T>
	class BST
	{
	private:
		class Node
		{
		public:
			T e;
			Node* left;
			Node* right;
			Node(T e):e(e),left(nullptr),right(nullptr){}
		};
		Node* root;
		int size;
	public:
		BST():root(nullptr),size(0){}
		int getSize()
		{
			return size;
		}
		bool isEmpty()
		{
			return (size == 0);
		}
		// 向二分搜索树中添加新的元素e
		void add(T e)
		{
			root = add(root,e);
		}	
	private:
		// 向以node为根的二分搜索树中插入元素e，递归算法
		// 返回插入新节点后二分搜索树的根
		Node* add(Node* node,T e)
		{
			if(node == nullptr)
			{
				++size;
				Node* ret = new Node(e);
				return ret;
			}
			if(e < node->e)
			{
				node->left = add(node->left,e);
			}
			if(e > node->e)
			{
				node->right = add(node->right,e);
			}
			return node;
		}
	public:
		// 看二分搜索树中是否包含元素e
		bool contains(T e)
		{
			return contains(root,e);
		}
	private:
		// 看以node为根的二分搜索树中是否包含元素e, 递归算法
		bool contains(Node* node, T e)
		{
			if(node == nullptr)
				return false;
			if(e == node->e)
				return true;
			else if(e < node->e)
				return contains(node->left,e);
			else //e > node->e
				return contains(node->right,e);
		}
	public:
		// 二分搜索树的前序遍历
		void preOrder()
		{
			preOrder(root);
		}
	private:
		// 前序遍历以node为根的二分搜索树, 递归算法
		void preOrder(Node* node)
		{
			if(node == nullptr)
				return;
			std::cout << node->e << std::endl;
			preOrder(node->left);
			preOrder(node->right);
		}
	public:
		// 二分搜索树的非递归前序遍历
		void preOrderNR()
		{
			using namespace std;
			//使用栈
			stack<Node> pre;
			pre.push(root);
			while(!pre.empty())
			{
				Node* cur = pre.pop();
				std::cout << cur->e ;
				if(cur->right != nullptr)
					pre.push(cur->right);
				if(cur->left != nullptr)
					pre.push(cur->left);
			}
		}
	};
	
int main()
{
	BST<int>* bst = new BST<int>();
	int a[] = {4,2,6,1,3,5,7};
	for(int x:a)
	{
		bst->add(x);
	}
	bst->preOrder();
	bst->preOrderNR();
}
