#include <iostream>
//改isEmpty
//改Node为外部类
//改toString


template <typename T>
class LinkedList
{
private:
	class Node
	{
	public:
		T e;
		Node* next;
		Node():next(nullptr){}
		Node(T e):e(e),next(nullptr){}
		Node(T e,Node* next):e(e),next(next){}
		~Node(){next = nullptr;}
	};
	Node* dummyHead;
	int size;
	
public:
	LinkedList()
	{
		dummyHead = new Node();
		size = 0;
	}
	~LinkedList()
	{
		delete dummyHead;
	}
	// 获取链表中的元素个数
	int getSize() const 
	{
		return size;
	}
	// 返回链表是否为空
	bool isEmpyt() const 
	{
		return (size == 0);
	}
	// 在链表的index(0-based)位置添加新的元素e
	void add(int index,T e)
	{
		if(index > size || index < 0 )
			throw "This index is Error.";
		Node* prev = dummyHead;
		for(int i = 0 ; i < index ; ++i)
		{
			prev = prev->next;
		}
		prev->next = new Node(e,prev->next);
		++size;
	}
	// 在链表头添加新的元素e
	void addFirst(T e)
	{
		add(0,e);
	}
	// 在链表末尾添加新的元素e
	void addLast(T e)
	{
		add(size,e);
	}
	// 获得链表的第index(0-based)个位置的元素
    T getData(int index) const 
	{
		if(index >= size || index < 0 )
			throw "This index is Error.";
		Node* cur = dummyHead->next;
		for(int i = 0 ; i < index ; ++i)
		{
			cur = cur->next;
		}
		return cur->e;
	}
	// 获得链表的第一个元素
	T getFirst() const
	{
		return getData(0);
	}
	// 获得链表的最后一个元素
	T getLast() const
	{
		return getData(size - 1);
	}
	// 修改链表的第index(0-based)个位置的元素为e
	void set(int index,T e)
	{
		if(index >= size || index < 0 )
			throw "This index is Error.";
		Node* cur = dummyHead->next;
		for(int i = 0 ; i < index ; ++i)
		{
			cur = cur->next;
		}
		cur->e = e;
	}
	// 查找链表中是否有元素e
	bool contains(T e)
	{
		Node* cur = dummyHead->next;
		while(cur != nullptr)
		{
			if(cur->e == e)
				return true;
			cur = cur->next;
		}
		return false;
	}
	// 从链表中删除index(0-based)位置的元素, 返回删除的元素
    T remove(int index)
	{
		if(index >= size || index < 0 )
			throw "This index is Error.";
		Node* prev = dummyHead;
		for(int i = 0 ; i < index ; ++i)
		{
			prev = prev->next;
		}
		Node* retNode = prev->next;
		prev->next = retNode->next;
		retNode->next = nullptr;
		-- size;
		return retNode->e;
	}
	// 从链表中删除第一个元素, 返回删除的元素
	T removeFirst()
	{
		return remove(0);
	}
	// 从链表中删除最后一个元素, 返回删除的元素
	T removeLast()
	{
		return remove(size - 1);
	}
	// 从链表中删除元素e
	void removeElement(T e)
	{
		Node* prev = dummyHead;
		while(prev->next != nullptr)
		{
			if(prev->next->e == e)
				break;
			prev = prev->next;
		}
		if(prev->next != nullptr)
		{
			Node* delNode = prev->next;
			prev->next = delNode->next;
			delNode->next = nullptr;
			-- size;
		}
	}
	//打印链表
	void toString()
	{
		std::cout << "dummyHead->";
		Node* cur = dummyHead->next;
		while(cur != nullptr)
		{
			std::cout << cur->e << "->";
			cur = cur->next;
		}
		std::cout << "Null" << std::endl;
	}
};

int main()
{
	auto link = new LinkedList<int>;
	for(int i = 0 ; i < 10 ; ++i)
	{
		link->addFirst(i);
	}
	std::cout << link->getSize() << std::endl;
	link->toString();
	link->add(1,111);
	link->addLast(999);
	link->toString();
	std::cout << link->getData(1) << std::endl;
	std::cout << link->getFirst() << std::endl;
	std::cout << link->getLast() << std::endl;
	link->set(1,666);
	link->toString();
	std::cout << link->contains(777) << std::endl;
	link->remove(0);
	std::cout << link->getSize() << std::endl;
	link->toString();
	link->removeFirst();
	link->toString();
	link->removeLast();
	link->toString();
	link->removeElement(5);
	link->toString();
	std::cout << link->getSize() << std::endl;
}





#include <iostream>
	
template <typename T>
class LinkedList
{
public:
	class Node
	{
	public:
		T e;
		Node* next;
		Node():next(nullptr){}
		Node(T e):e(e),next(nullptr){}
		Node(T e,Node* next):e(e),next(next){}
		~Node(){next = nullptr;}
	};
private:
	Node* dummyHead;
	int size;
	
public:
	LinkedList()
	{
		dummyHead = new Node();
		size = 0;
	}
	~LinkedList()
	{
		delete dummyHead;
	}
	
	// 获取链表中的元素个数
	int getSize() const 
	{
		return size;
	}
	// 返回链表是否为空
	bool isEmpyt() const 
	{
		return (size == 0);
	}
	// 在链表的index(0-based)位置添加新的元素e
	void add(int index,T e)
	{
		if(index > size || index < 0 )
			throw "This index is Error.";
		Node* prev = dummyHead;
		for(int i = 0 ; i < index ; ++i)
		{
			prev = prev->next;
		}
		prev->next = new Node(e,prev->next);
		++size;
	}
	// 在链表头添加新的元素e
	void addFirst(T e)
	{
		add(0,e);
	}
	// 在链表末尾添加新的元素e
	void addLast(T e)
	{
		add(size,e);
	}
	// 获得链表的第index(0-based)个位置的元素
    T getData(int index) const 
	{
		if(index >= size || index < 0 )
			throw "This index is Error.";
		Node* cur = dummyHead->next;
		for(int i = 0 ; i < index ; ++i)
		{
			cur = cur->next;
		}
		return cur->e;
	}
	// 获得链表的第一个元素
	T getFirst() const
	{
		return getData(0);
	}
	// 获得链表的最后一个元素
	T getLast() const
	{
		return getData(size - 1);
	}
	// 修改链表的第index(0-based)个位置的元素为e
	void set(int index,T e)
	{
		if(index >= size || index < 0 )
			throw "This index is Error.";
		Node* cur = dummyHead->next;
		for(int i = 0 ; i < index ; ++i)
		{
			cur = cur->next;
		}
		cur->e = e;
	}
	// 查找链表中是否有元素e
	bool contains(T e)
	{
		Node* cur = dummyHead->next;
		while(cur != nullptr)
		{
			if(cur->e == e)
				return true;
			cur = cur->next;
		}
		return false;
	}
	// 从链表中删除index(0-based)位置的元素, 返回删除的元素
    T remove(int index)
	{
		if(index >= size || index < 0 )
			throw "This index is Error.";
		Node* prev = dummyHead;
		for(int i = 0 ; i < index ; ++i)
		{
			prev = prev->next;
		}
		Node* retNode = prev->next;
		prev->next = retNode->next;
		retNode->next = nullptr;
		-- size;
		return retNode->e;
	}
	// 从链表中删除第一个元素, 返回删除的元素
	T removeFirst()
	{
		return remove(0);
	}
	// 从链表中删除最后一个元素, 返回删除的元素
	T removeLast()
	{
		return remove(size - 1);
	}
	// 从链表中删除元素e
	void removeElement(T e)
	{
		Node* prev = dummyHead;
		while(prev->next != nullptr)
		{
			if(prev->next->e == e)
				break;
			prev = prev->next;
		}
		if(prev->next != nullptr)
		{
			Node* delNode = prev->next;
			prev->next = delNode->next;
			delNode->next = nullptr;
			-- size;
		}
	}
	//打印链表
	void toString()
	{
		Node* cur = dummyHead->next;
		while(cur != nullptr)
		{
			if(cur->next == nullptr)
			{
				std::cout << cur->e;
				break;
			}
			std::cout << cur->e << "->";
			cur = cur->next;
		}
	}
};

template <typename T>
class Stack
{
public:
	virtual int getSize() const = 0;
	virtual bool isEmpyt() const = 0;
	virtual T peek() const = 0;
	virtual void push(T e) = 0;
	virtual T pop() = 0;
};

template < typename T>
class LinkedStack:public Stack<T>
{
private:
	LinkedList<T>* list;
public:
	LinkedStack()
	{
		list = new LinkedList<T>(); 
	}
	~LinkedStack()  
	{
		delete list;
	}
	int getSize() const
	{
		return list->getSize();
	}
	bool isEmpyt() const
	{
		return list->isEmpyt();
	}
	T peek() const
	{
		return list->getFirst();
	}
	void push(T e)
	{
		list->addFirst(e);
	}
	T pop()
	{
		return list->removeFirst();
	}
	void toString()
	{
		std::cout << " top";
		list->toString();
		std::cout <<" bootom" <<std::endl;
	}
};

int main()
{
	LinkedStack<int>* link = new LinkedStack<int>();
	for(int i = 0 ; i < 10 ; ++i)
	{
		link->push(i);
	}
	link->toString();
	std::cout << "size:" << link->getSize() << std::endl;
	std::cout << "peek:" << link->peek() << std::endl;
	std::cout << "pop:" << link->pop() << std::endl;
	link->toString();
}
