优先队列
出队顺序和入队顺序无关，和优先级有关
动态：不在于排序，因为随时会有新的元素
使用堆实现，入队出队复杂度O（logn）
(只要O(logn),一般和树有关)
堆：
二叉堆 --> 使用二叉树实现 --> 特殊性质的二叉树 --> 完全二叉树（满足平衡二叉树） --> 右下侧可以缺节点(就满二叉树而言) --> 即，把元素顺序排列成树的形状（一层一层放） -->  堆中每个节点的值总是不大于其父节点的值 --> 根节点最大 --> 最大堆
用数组存储二叉堆：
parent(i) = (i-1) /2
left child (i) = 2 * i + 1
right child(i) = 2 * i + 2
添加元素 --> Sift up (上浮)
和父亲节点依次比较
取出元素 --> Sift down (下沉)
最大堆 --> 和最后一个元素交换位置 --> 删掉如今最后一个元素 --> 调整--> 根节点和自己的左右孩子比较，并和较大的交换位置 
将n个元素插入空堆中，复杂度O(n log n)
heapify：将任意数组整理成堆的形状，复杂度O(n)
操作非叶子节点，从最后非叶子节点处理，进行Sift down （排除了所有叶子节点，就是所有非叶子节点）
最后一个非叶子节点：根据最后一个节点索引，求父亲节点即可

d叉堆
索引堆：
操作中间元素
